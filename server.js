
var request = require('request');
var spotifywebapi = require('spotify-web-api-node');
var storage = require('node-persist');
var moment = require('moment');

var trackArray = [];
var numberOfShows = 999;
var topTracksSearched = 0;
var topTracksToSearch = 0;
var artistsToSearch = 0;
var artistsSearched = 0;
var delayBetweenSpotifyAPIcalls = 400;
var eventDateSince = moment().format("YYYY-MM-DD")
var eventDateUntil = moment(new Date().setFullYear(new Date().getFullYear() + 1)).format("YYYY-MM-DD")

// Code from request URL that was the result of opening the authorization URL generated by getToken.js
var code = "AQDu79yI5Ab2TPjd-eQfryd9wUrlFuLSzgzQAY7kMGtOHo49xb3OeOdXMbsPEc0Q2cqUbo3Xwvwr0GAYllaVuUksmpW0588XtS6GDznu3MmhdOs1H0Q7Y4sEYE9tP2H6klP3e1pQiFPuhUk-uJBJflgucuYpG-C1W1hbcEJfMJR1rkaUJlvUAErCrhFPjra_UyeIYy8V7hyli6gTJG58cx5tyMW3RX1j7A-r7dH5kmu4AEImEpzTIA";

// Values from this app's settings in your developer account at developer.spotify.com
var clientId = '33dcfa289c814da6835416045e153409';
var clientSecret = 'fd6495784ad64660a5634bcd355a2ed8';
var redirectUri = 'http://localhost/'; // Must add this, identically, to your app's settings

var credentials = {
  clientId : clientId,
  clientSecret : clientSecret,
  redirectUri : redirectUri
};

var spotify = new spotifywebapi(credentials);

/**
 * 
 * Check node-persist storage to see if we already have a Spotify authorization refresh token saved
 *
 */

function checkForRefreshToken(){
	if (storage.getItemSync('refresh_token') != ""){
		console.log("We have a refresh token. Getting new access token via refreshAccessToken")
		refreshAccessToken();	
	} else {
		console.log("No refresh token found in storage. Please update var 'code' by running getToken.js and visiting the authorization URL, then setting var 'code' equal to resulting request string")
		getAuthCode();	
	}
};

/**
 * 
 * Uses hardcoded var 'code' to get an access token via Spotify API
 * Access token only lasts an hour. Must then use refresh token to get a new one
 * This method saves access token and refresh token to local storage for use on future calls
 *
 */

function getAuthCode(){

	// Retrieve an access token and a refresh token
	spotify.authorizationCodeGrant(code)
	  .then(function(data) {
	    console.log('The token expires in ' + data.body['expires_in']);
	    console.log('The access token is ' + data.body['access_token']);
	    console.log('The refresh token is ' + data.body['refresh_token']);

	    // Set the access token on the API object to use it in later calls
	    spotify.setAccessToken(data.body['access_token']);
	    spotify.setRefreshToken(data.body['refresh_token']);
 
		storage.setItemSync('refresh_token',data.body['refresh_token']);
		console.log(storage.getItemSync('access_token'));	
		console.log(storage.getItemSync('refresh_token'));
		
	  }, function(err) {
	    console.log('Unable to get tokens in getAuthCode', err);
	  });
	  
}

/**
 * 
 * Retrieves the Spotify API refresh token from local storage
 * then uses that token to get a new access token from Spotify
 *
 */

function refreshAccessToken(){
	
	spotify.setRefreshToken(storage.getItemSync('refresh_token'))
	
	spotify.refreshAccessToken()
	.then(function(data) {
	  console.log('The access token has been refreshed!');

	  spotify.setAccessToken(data.body['access_token']);
	}, function(err) {
	  console.log('Could not refresh access token in refreshAccessToken', err);
	});	

}


/**
 * 
 * Use Facebook API to get all events from White Oak Music Hall page
 *
 */

function getShows() {
	
	console.log("Getting all WOMH shows from " + eventDateSince + ' to ' + eventDateUntil)
	
	showsUrl = 'https://graph.facebook.com/WhiteOakMH/events?access_token=261112694330482|913de71225b6470338f19c73c4149453';
	showsUrl += '&since=' + eventDateSince + '&until=' + eventDateUntil + '&limit=' + numberOfShows;
	
	request(showsUrl, function(error, response, eventsJSON) {
		if (!error) {
			getEvents(eventsJSON);
		} else {
			console.log("Something went wrong in getShows")
		}
	});
};


/**
 *
 * Method to iterate White Oak Music Hall's returned event JSON and query Spotify API
 * @param  {eventsJSON} JSON object containing WOMH's upcoming events
 *
 */

function getEvents(eventsJSON) {

	json = JSON.parse(eventsJSON);	
	
	var x = 0;;
	console.log("Parsed the following possible artist names from WOMH's events:")
	json.data.forEach(function(event) {
		var currentArtistEventName = event.name.trim(); // WOMH event name string. May contain multiple artists
			// Parse out the artist names from the event name string
			var artistArray = currentArtistEventName.split(/[,/\+]+/); // WOMH uses  , / and + to separate artist names
			artistArray.forEach(function(artist){
				console.log(artist.trim());
				doSetTimeout(artist.trim(), x);			
				artistsToSearch++;
				x++;			
			})
	});
	
	// dispatch a Spotify API search with increasingly long delay so calls are offset sequentially to get around API rate limiting
	function doSetTimeout(currentArtist, x) {
	  setTimeout(function() { 
		  searchForArtist(currentArtist); 
	  }, (x*delayBetweenSpotifyAPIcalls));
	}	
}

/**
 *
 * Method to search Spotify API for artist name. 
 * @param  {currentArtist} Artist name
 *
 */

function searchForArtist(currentArtist){
	
	spotify.searchArtists(currentArtist,{ limit : 1 })
	.then(function(data) {
		artistsSearched++;
		returnedRecords = data.body.artists.total;
		if(returnedRecords > 0){
			artistName = data.body.artists.items[0].name;
			artistID = data.body.artists.items[0].id;
	  			console.log("\nSearch: " + currentArtist + "\nFound:  " + artistName);
				if (currentArtist.toLowerCase() == artistName.toLowerCase()){
					topTracksToSearch++;
					getArtistTopTracks(artistID)
				}else{
					console.log("                         ** DID NOT MATCH **")
				}
				
		}	
	}, function(err) {
	  console.error(err);
	}).then(function(){

	});				
}

/**
 *
 * Method to search Spotify API for an artist's most listened to tracks. 
 * @param  {artistID}
 *
 */

function getArtistTopTracks(artistID){

  spotify.getArtistTopTracks(artistID,'US')
    .then(function(data) {
		 topTracksSearched++;
		 if (data.body.tracks.length > 0){
			 artistTrack = "spotify:track:" + data.body.tracks[0].id;
			 trackArray.push(artistTrack);
		 }		 
      }, function(err) {
      	console.log('Something went wrong while getting artistID ' + artistID + ' via getArtistTopTracks ', err);
    });	
	
}

/**
 *
 * Method to check if all Spotify API requests have come back
 * If so, slice the resulting trackIDs in trackArray into chunks since Spotify API 
 * only allows so many tracks (currently 100) added at a time
 *
 * @param  {artistID}
 *
 */

function checkForCompletion(){
	if ((topTracksSearched == topTracksToSearch) && (artistsToSearch == artistsSearched)){
		console.log("\ntopTracksToSearch: " + topTracksToSearch)
		console.log("topTracksSearched: " + topTracksSearched)
		console.log("artistsToSearch: " + artistsToSearch)
		console.log("artistsSearched: " + artistsSearched)
		// Facebook returns events in reverse chron order. 
		// Reverse the array so our tracks appear in event chronological order in our playlist
		trackArray.reverse();

		var i,j,temparray,chunk = 100;
		for (i=0,j=trackArray.length; i<j; i+=chunk) {
		    if (i==0){ 
				// First time, use spotify.replaceTracksInPlaylist to REPLACE all tracks in the playlist with the first chunk
				replaceTracks(trackArray.slice(i,i+chunk))
				console.log("Sliced off the first " + chunk + " tracks and sent to replaceTracks")
			}else{
				// Then all remaining times, use spotify.addTracksToPlaylist to ADD the next chunk(s)
				doSetTimeoutForLeftovers(trackArray.slice(i,i+chunk), i, chunk)
			}
		}
		clearInterval(checkForCompletionInterval);
	}	
}

/**
 *
 * The Spotify API is slow to update that first chunk using spotify.replaceTracksInPlaylist
 * Dispatch a timer so we don't try to add the leftover tracks before the first batch has completed updating
 *
 * @param  {artistID}
 *
 */

function doSetTimeoutForLeftovers(trackArray, i, chunk) {
  setTimeout(function() { 
	updatePlaylistWithLeftovers(trackArray)
	console.log("Remaining " + trackArray.length + " tracks sent to updatePlaylistWithLeftovers")

  }, (2000));
}

/**
 *
 * Method to REPLACE all tracks in a playlist with array of tracksIDs
 * @param  {trackArray} Array of trackIDs
 *
 */

function replaceTracks(trackArray){
	spotify.replaceTracksInPlaylist('jeffpeoples', '65GNg2l0IspPA0QCAQqzfs', trackArray)
    .then(function(data) {
		 console.log("replaceTracks successful")
      }, function(err) {
      	console.log('Something went wrong while replacing playlist tracks via replaceTracks', err);
    });		
	
}

/**
 *
 * Method to ADD tracks to a playlist with array of tracksIDs
 * @param  {trackArray} Array of trackIDs
 *
 */

function updatePlaylistWithLeftovers(trackArray){
	spotify.addTracksToPlaylist('jeffpeoples', '65GNg2l0IspPA0QCAQqzfs', trackArray)
	  .then(function(data) {
	    console.log('Remaining ' + trackArray.length + ' added succesfully.');
	  }, function(err) {
	    console.log('Something went wrong while adding leftover tracks via updatePlaylistWithLeftovers', err);
	  });
}






// Clear some space in terminal
console.log(" ")

//Create a local storage instance using node-persist
storage.initSync();

checkForRefreshToken();

getShows();

// Periodically see if all Spotify API requests have come back
let checkForCompletionInterval = setInterval(() => {
	checkForCompletion();
}, 3000);







//process.on('exit', function(){
	// possible future use
//});


